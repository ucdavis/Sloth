/**
 * Sloth API v1
 * Scrubber Loader & Online Transaction Hub
 *
 * OpenAPI spec version: v1
 * Contact: jpknoll@ucdavis.edu
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from 'url';

import * as isomorphicFetch from 'isomorphic-fetch';

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://localhost".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
};

export interface ApiKey {
    "id"?: string;
    "user"?: User;
    "issued"?: Date;
    "revoked"?: Date;
}

export interface IdentityUserClaimString {
    "id"?: number;
    "userId"?: string;
    "claimType"?: string;
    "claimValue"?: string;
}

export interface IdentityUserLoginString {
    "loginProvider"?: string;
    "providerKey"?: string;
    "providerDisplayName"?: string;
    "userId"?: string;
}

export interface IdentityUserRoleString {
    "userId"?: string;
    "roleId"?: string;
}

export interface Scrubber {
    "id"?: string;
    "uri"?: string;
    "chart": string;
    "organizationCode": string;
    "batchDate": Date;
    "batchSequenceNumber": number;
    "transactions": Array<Transaction>;
}

export interface Transaction {
    "id"?: string;
    "creator"?: User;
    "status"?: TransactionStatusEnum;
    "merchantTrackingNumber"?: string;
    "processorTrackingNumber"?: string;
    "originCode": string;
    "documentNumber": string;
    "kfsTrackingNumber"?: string;
    "transactionDate": Date;
    "transfers"?: Array<Transfer>;
    "scrubber"?: Scrubber;
}

export type TransactionStatusEnum = "Scheduled" | "Completed" | "Cancelled";
export interface Transfer {
    "id"?: string;
    "transaction"?: Transaction;
    "amount": number;
    "chart": number;
    "account": string;
    "subAccount"?: string;
    "objectCode": string;
    "subObjectCode"?: string;
    "objectType"?: string;
    "sequenceNumber"?: number;
    "description": string;
    "direction": TransferDirectionEnum;
    "fiscalYear"?: number;
    "fiscalPeriod"?: number;
    "project"?: string;
    "referenceId"?: string;
}

export type TransferDirectionEnum = "Credit" | "Debit";
export interface User {
    "keys"?: Array<ApiKey>;
    "id"?: string;
    "userName"?: string;
    "normalizedUserName"?: string;
    "email"?: string;
    "normalizedEmail"?: string;
    "emailConfirmed"?: boolean;
    "passwordHash"?: string;
    "securityStamp"?: string;
    "concurrencyStamp"?: string;
    "phoneNumber"?: string;
    "phoneNumberConfirmed"?: boolean;
    "twoFactorEnabled"?: boolean;
    "lockoutEnd"?: Date;
    "lockoutEnabled"?: boolean;
    "accessFailedCount"?: number;
    "roles"?: Array<IdentityUserRoleString>;
    "claims"?: Array<IdentityUserClaimString>;
    "logins"?: Array<IdentityUserLoginString>;
}



/**
 * ScrubbersApi - fetch parameter creator
 */
export const ScrubbersApiFetchParamCreator = {
    /**
     *
     * @param id
     */
    v1ScrubbersByIdDelete(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling v1ScrubbersByIdDelete");
        }
        const baseUrl = `/v1/Scrubbers/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = Object.assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param id
     */
    v1ScrubbersByIdGet(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling v1ScrubbersByIdGet");
        }
        const baseUrl = `/v1/Scrubbers/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = Object.assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param id
     * @param value
     */
    v1ScrubbersByIdPut(params: {  "id": number; "value"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling v1ScrubbersByIdPut");
        }
        const baseUrl = `/v1/Scrubbers/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["value"]) {
            fetchOptions.body = JSON.stringify(params["value"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = Object.assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetch Top 1 Scrubber
     */
    v1ScrubbersGet(options?: any): FetchArgs {
        const baseUrl = `/v1/Scrubbers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = Object.assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param value
     */
    v1ScrubbersPost(params: {  "value"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/v1/Scrubbers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["value"]) {
            fetchOptions.body = JSON.stringify(params["value"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = Object.assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ScrubbersApi - functional programming interface
 */
export const ScrubbersApiFp = {
    /**
     *
     * @param id
     */
    v1ScrubbersByIdDelete(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ScrubbersApiFetchParamCreator.v1ScrubbersByIdDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param id
     */
    v1ScrubbersByIdGet(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Scrubber> {
        const fetchArgs = ScrubbersApiFetchParamCreator.v1ScrubbersByIdGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param id
     * @param value
     */
    v1ScrubbersByIdPut(params: { "id": number; "value"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ScrubbersApiFetchParamCreator.v1ScrubbersByIdPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetch Top 1 Scrubber
     */
    v1ScrubbersGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Scrubber>> {
        const fetchArgs = ScrubbersApiFetchParamCreator.v1ScrubbersGet(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param value
     */
    v1ScrubbersPost(params: { "value"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ScrubbersApiFetchParamCreator.v1ScrubbersPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ScrubbersApi - object-oriented interface
 */
export class ScrubbersApi extends BaseAPI {
    /**
     *
     * @param id
     */
    v1ScrubbersByIdDelete(params: {  "id": number; }, options?: any) {
        return ScrubbersApiFp.v1ScrubbersByIdDelete(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param id
     */
    v1ScrubbersByIdGet(params: {  "id": number; }, options?: any) {
        return ScrubbersApiFp.v1ScrubbersByIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param id
     * @param value
     */
    v1ScrubbersByIdPut(params: {  "id": number; "value"?: string; }, options?: any) {
        return ScrubbersApiFp.v1ScrubbersByIdPut(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetch Top 1 Scrubber
     */
    v1ScrubbersGet(options?: any) {
        return ScrubbersApiFp.v1ScrubbersGet(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param value
     */
    v1ScrubbersPost(params: {  "value"?: string; }, options?: any) {
        return ScrubbersApiFp.v1ScrubbersPost(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ScrubbersApi - factory interface
 */
export const ScrubbersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param id
         */
        v1ScrubbersByIdDelete(params: {  "id": number; }, options?: any) {
            return ScrubbersApiFp.v1ScrubbersByIdDelete(params, options)(fetch, basePath);
        },
        /**
         *
         * @param id
         */
        v1ScrubbersByIdGet(params: {  "id": number; }, options?: any) {
            return ScrubbersApiFp.v1ScrubbersByIdGet(params, options)(fetch, basePath);
        },
        /**
         *
         * @param id
         * @param value
         */
        v1ScrubbersByIdPut(params: {  "id": number; "value"?: string; }, options?: any) {
            return ScrubbersApiFp.v1ScrubbersByIdPut(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetch Top 1 Scrubber
         */
        v1ScrubbersGet(options?: any) {
            return ScrubbersApiFp.v1ScrubbersGet(options)(fetch, basePath);
        },
        /**
         *
         * @param value
         */
        v1ScrubbersPost(params: {  "value"?: string; }, options?: any) {
            return ScrubbersApiFp.v1ScrubbersPost(params, options)(fetch, basePath);
        },
    };
};


/**
 * TransactionsApi - fetch parameter creator
 */
export const TransactionsApiFetchParamCreator = {
    /**
     *
     * @summary Fetch Transactions by Id
     * @param id
     */
    v1TransactionsByIdGet(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling v1TransactionsByIdGet");
        }
        const baseUrl = `/v1/Transactions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = Object.assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetch Top 1 Transactions
     */
    v1TransactionsGet(options?: any): FetchArgs {
        const baseUrl = `/v1/Transactions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = Object.assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param id
     */
    v1TransactionsProcessorByIdGet(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling v1TransactionsProcessorByIdGet");
        }
        const baseUrl = `/v1/Transactions/processor/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = Object.assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = Object.assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * TransactionsApi - functional programming interface
 */
export const TransactionsApiFp = {
    /**
     *
     * @summary Fetch Transactions by Id
     * @param id
     */
    v1TransactionsByIdGet(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Transaction> {
        const fetchArgs = TransactionsApiFetchParamCreator.v1TransactionsByIdGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetch Top 1 Transactions
     */
    v1TransactionsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Transaction>> {
        const fetchArgs = TransactionsApiFetchParamCreator.v1TransactionsGet(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param id
     */
    v1TransactionsProcessorByIdGet(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Transaction> {
        const fetchArgs = TransactionsApiFetchParamCreator.v1TransactionsProcessorByIdGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TransactionsApi - object-oriented interface
 */
export class TransactionsApi extends BaseAPI {
    /**
     *
     * @summary Fetch Transactions by Id
     * @param id
     */
    v1TransactionsByIdGet(params: {  "id": string; }, options?: any) {
        return TransactionsApiFp.v1TransactionsByIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetch Top 1 Transactions
     */
    v1TransactionsGet(options?: any) {
        return TransactionsApiFp.v1TransactionsGet(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param id
     */
    v1TransactionsProcessorByIdGet(params: {  "id": string; }, options?: any) {
        return TransactionsApiFp.v1TransactionsProcessorByIdGet(params, options)(this.fetch, this.basePath);
    }
};

/**
 * TransactionsApi - factory interface
 */
export const TransactionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Fetch Transactions by Id
         * @param id
         */
        v1TransactionsByIdGet(params: {  "id": string; }, options?: any) {
            return TransactionsApiFp.v1TransactionsByIdGet(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetch Top 1 Transactions
         */
        v1TransactionsGet(options?: any) {
            return TransactionsApiFp.v1TransactionsGet(options)(fetch, basePath);
        },
        /**
         *
         * @param id
         */
        v1TransactionsProcessorByIdGet(params: {  "id": string; }, options?: any) {
            return TransactionsApiFp.v1TransactionsProcessorByIdGet(params, options)(fetch, basePath);
        },
    };
};
